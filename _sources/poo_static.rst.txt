###############################
Membres d'instància i de classe
###############################

Tot i que habitualment els membres que definim a les nostres classes,
estan orientats a cada instància concreta de la classe, hi ha ocasions en
que ens cal disposar de mètodes o/i propietats que facin referència a tota
la classe i no a una instància concreta d'aquesta.

Vides vàlides
=============

Ja ens hem adonat que hi ha diferència depenent de si els mètodes són
marcats o no amb ``static``. Ja va tocant presentar aquest punt una mica
més formalment.

Quan un mètode no és marcat amb ``static``, es diu que el mètode és
d'instància o també dinàmic. Els mètodes d'instància reben sempre un
paràmetre implícit anomenat ``this`` que fa referència a la instància en
la que s'executaran.

En tenim molts exemples de mètodes d'instància, per exemple:

.. code-block:: java
    :linenos:
    :emphasize-lines: 3

    public void setVides(int vides) {
        if (vides >= 0) {
            this.vides = vides;
        }
    }

De vegades però, ens trobem que hi ha mètodes que no tenen sentit per una
instància concreta sinó que són més generals per la classe.

Deixa'm que et posi un exemple. El mètode ``setVides()`` comprova si les
vides són vàlides. En la situació actual, les vides són vàlides quan són
com a mínim 0. Què passaria, però si les comprovacions fossin més
sofisticades pel nostre amic Renat? Imagina't, potser no pot tenir més de
7 vides o, només un nombre senar de vides o zero, o només un nombre de
vides primer… Pots esperar qualsevol cosa d'un gat tan especial.

En comptes d'implementar aquestes condicions dins del *setter*, que, com
veus, podrien arribar a ser complexes, potser ens interessarà crear un nou
mètode que rebi un nombre de vides i ens digui si és vàlid o no.

.. code-block:: java
    :linenos:

    public boolean esValidPerVides(int valor) {
        return valor >= 0;
    }

    public void setVides(int vides) {
        if (esValidPerVides(vides)) {
            this.vides = vides;
        }
    }

Públic o privat
===============

Com que ``esValidPerVides()`` té un ús purament intern, podríem considerar
fer-lo privat. 

És una bona pràctica mirar marcar els membres d'una classe per defecte com a
``private``. Quan fem un membre ``public`` estem comprometent la
possibilitat de modificar-lo en el futur.

Per exemple, si per alguna raó en el futur trobem que ``esValidPerVides()``
hauria d'haver-se dit ``videsValidesPerRenat()`` i fos públic, ens tocaria, no
només reanomenar el mètode a ``GatRenat`` sinó també fer-ho a *tots* els
programes que el fan servir. Alguns d'aquests programes podrien estar fets per
altres desenvolupadors i projectes!

Per descomptat, no podem portar aquesta regla de *màxim privat* a l'extrem, o
la nostra classe no permetria cap interacció.

Tornant a ``esValidPerVides()`` però, podria ser molt útil pels usuaris de
``GatRenat`` el saber si les vides són o no vàlides abans de passar-les a
``setVides()``.

Per exemple, imagina que, a ``UsaGatRenat`` ens interessa mostrar un missatge
d'error si no són vàlides les vides a assignar.

És a dir, hauríem de primer intentar assignar i després comprovar si
l'assignació s'ha produït.

.. code-block:: java
    :linenos:
    :emphasize-lines: 2

    int videsLlegides = Integer.parseInt(Entrada.readLine());
    if (renat.esValidPerVides(videsLlegides)) {
        renat.setVides(videsLlegides);    // només assigno si sé que són vàlides
    } else {
        System.out.println("ERROR: valor no vàlid per vides");
    }

Amb la definició de ``GatRenat`` actual, sense ``esValidPerVides()`` públic,
hauríem de fer quelcom tan rebuscat com:

.. code-block:: java
   :linenos:

    renat.setVides(videsLlegides);
    if (renat.getVides() != videsLlegides) {
        System.out.println("ERROR: valor no vàlid per vides");
    }

Instàncies perdudes
===================

Per la implementació de ``setVides()`` sabem que els dos codis anteriors són
equivalents. Però, què passaria si ``setVides()`` tingués altres efectes
coŀlaterals indesitjats?  Per exemple, que si se li intenta assignar unes vides
no vàlides, el gat s'estira.

Una opció per evitar cridar a ``setVides()`` si les vides no són vàlides seria:

.. code-block:: java
    :linenos:
    :emphasize-lines: 1,2

    GatRenat unaInstanciaQueNoFareServirGaire = new GatRenat();
    if (unaInstanciaQueNoFareServirGaire.esValidPerVides(videsLlegides)) {
        renat = new GatRenat(videsLlegides);
    } else {
        System.out.println("ERROR: valor no vàlid per vides");
    }

Quin nom més llarg, oi? Ens està dient que estem creant una instància
*només* per saber si les vides són vàlides o no! Per molt que ho intentem
amagar amb la següent versió de codi, no deixa de ser absurd:

.. code-block:: java
    :linenos:
    :emphasize-lines: 1

    if (new GatRenat().esValidPerVides(videsLlegides)) {    // instància perduda
        renat = new GatRenat(videsLlegides);
    } else {
        System.out.println("ERROR: valor no vàlid per vides");
    }

Sense instàncies a perdre
=========================

El problema aquí és que comprovar si ``videsLlegides`` és o no un valor
vàlid per les vides d'un gat Renat, és quelcom *independent* d'una
instància concreta. És a dir, per qualsevol instància, el resultat de
``esValidPerVides()`` ha de ser el mateix. És un resultat que depen de la
classe i no de la instància.

El que voldríem fer és:

.. code-block:: java
    :linenos:
    :emphasize-lines: 2

    if (GatRenat.esValidPerVides(videsLlegides)) {    // no creem cap instància
        renat = new GatRenat(videsLlegides);
    } else {
        System.out.println("ERROR: valor no vàlid per vides");
    }

Però això ja ho hem fet abans! Declarant el mètode com ``static``

.. code-block:: java
    :linenos:
    :emphasize-lines: 1, 6

    public static boolean esValidPerVides(int valor) {
        return valor >= 0;
    }

    public void setVides(int vides) {
        if (esValidPerVides(vides)) {
            this.vides = vides;
        }
    }

Mètodes estàtics
================

Als mètodes estàtics els anomenarem també *mètodes de classe*.

Una particularitat dels mètodes de classe és que **no** disposen de la
referència ``this``. És clar, ``this`` fa referència a una instància i els
mètodes de classe no en tenen cap d'instància!

Fixa't que, des del codi del mètode d'instància ``setVides()``, podem
accedir sense problemes al mètode de classe ``esValidPerVides()`` però a
l'inrevés no. Des d'un mètode de classe ens caldrà crear una instància per
poder accedir a un mètode d'instància.

És molt típic fer servir mètodes de classe per oferir funcionalitats de
validació de valors, duplicació i comparació d'instàncies. Fins i tot
trobem implementacions que fan privat el constructor i només pots crear
instàncies a partir d'un mètode estàtic des del que podem controlar
coses com ara quantes instàncies es creen!

Estàtics en UML
===============

En UML els mètodes estàtics apareixen subratllats

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        +{static} esValidPerVides(int): boolean
        +setVides(int):
     }
     @enduml


|exerciseicon__T| :doc:`exercici_34_28_hora_static`

En quant les propietats
=======================

Les propietats també poden ser de classe.

Un dels exemples més típics és el de portar el comptador de quantes
instàncies d'una classe s'han creat.

Considera el següent codi, executa'l i intenta entendre el perquè de la sortida 

.. code-block:: java
    :linenos:

    /* Demostració d'ús de membres de classe */
    public class GatRenat {
        private static int numInstancies = 0;
        private int vides = 7;
        public GatRenat() {
            // constructor per defecte incrementa el nombre d'instàncies
            GatRenat.numInstancies++;
            System.out.println("Creat un nou gat Renat. Ja van " + numInstancies);
        }
        public static int getNumInstancies() {
            // retorna el nombre d'instàncies creades fins el moment
            return numInstancies;
        }
        public int getVides() { return vides; }
        public void setVides(int vides) { if (vides>=0) this.vides = vides; }
        public String toString() { return "Gat Renat amb " + vides + " vides"; }
        public static void main(String[] args) {
            System.out.println("Inicialment el nombre d'instàncies és: " +
                GatRenat.getNumInstancies());
            // crea uns quants GatRenat per demostrar l'ús de membres estàtics
            GatRenat[] gats = new GatRenat[10];
            for (int i=0; i < gats.length; i++) {
                gats[i] = new GatRenat();
                gats[i].setVides(i);    // canviem les vides només per distingir-los
                System.out.println("Tenim: " + gats[i] + " amb " +
                    gats[i].getNumInstancies() + " germanets");
            }
            // tornem a demanar a cadascun quants germans té
            System.out.println("I si tornem a demanar-los quants germans tenen, ens diuen:");
            for (int i=0; i < gats.length; i++) {
                System.out.println(gats[i] + " amb " +
                    gats[i].getNumInstancies() + " germanets");
            }
        }
    }

Hi ha diferents usos per les propietats estàtiques. Normalment les fem
finals per definir constants de la classe. De vegades, però, ens poden
interessar per guardar resultats que vulguem compartir entre les
instàncies, com ara el nom del fitxer en el que s'han d'emmagatzemar.

|exerciseicon__T| :doc:`exercici_34_29_unic`
