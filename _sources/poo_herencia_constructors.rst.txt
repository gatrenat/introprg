#######################
Herència i constructors
#######################

T'has plantejat què passa amb els constructors en el cas de l'herència?

Considera aquest codi:

.. code-block:: java
    :linenos:

    class Gat {
        public Gat() {
            System.out.println("Neix un Gat");
        }
    }

    class GatRenat extends Gat {
        public GatRenat() {
            System.out.println("Neix un Gat Renat");
        }
    }

    public class UsaGatRenat {
         public static void main(String[] args){
             System.out.println("Abans de crear un Gat Renat");
             GatRenat renat = new GatRenat();
             System.out.println("Un cop creat un Gat Renat");
         }
    }

La seva execució seria:

.. code-block:: console
    :emphasize-lines: 2-

    $ java UsaGatRenat
    Abans de crear un Gat Renat
    Neix un Gat
    Neix un Gat Renat
    Un cop creat un Gat Renat

Com pots veure, a la línia 16 creem una instància de ``GatRenat`` tot
cridant el constructor de ``GatRenat``. La sortida, però, ens mostra que
primer passa pel constructor de ``Gat`` i després pel de ``GatRenat``.

Com és possible si no hem fet cap ``new Gat()`` enlloc?

Ja imaginaràs que Java deu d'estar fent la crida pel seu compte de manera
amagada com tantes altres coses.

Fem-ho explícit. El que Java ens està col·locant és el següent:

.. code-block:: java
    :linenos:
    :emphasize-lines: 3

    class GatRenat extends Gat {
        public GatRenat() {
            super();
            System.out.println("Neix un Gat Renat");
        }
    }

És molt similar al ``this()``, però en comptes de *cridar* un constructor
de la mateixa classe, ho fa a un de la superclasse.

Ara que ja tenim descobert els moviments *amagats* de Java, entendrem que
les següents dues definicions són equivalents:

La primera, amb tot implícit:

.. code-block:: java
    :linenos:

    class Gat {}

La segona, amb tot explícit:

.. code-block:: java
    :linenos:

    class Gat extends Object {
        public Gat() {
            super();
        }
    }

De la mateixa manera que ``this()``, la crida ``super()`` només pot
aparèixer com a primera línia d'un constructor i, en cas que no hi sigui,
Java l'afegirà per defecte.

Això ens porta a una situació que pot esdevenir problemàtica. Considera
la següent definició de ``Gat``:

.. code-block:: java
    :linenos:

    class Gat {
        private int vides;
        public Gat(int vides) {
            this.vides = vides;
        }
        public int getVides() { return vides; }
    }

És a dir, ``Gat`` no té constructor per defecte.

Sabem que en aquesta situació no podem fer una instància de ``Gat`` així:

.. code-block:: java
    :linenos:

    Gat gat = new Gat();    // no troba el constructor per defecte

Què passarà amb la subclasse?

.. code-block:: java
    :linenos:

    class GatRenat extends Gat {}

Un codi aparentment tan innocent com l'anterior, de sobte no compila!

És clar, Java està posant-nos la crida al constructor per defecte de la
superclasse:

.. code-block:: java
    :linenos:
    :emphasize-lines: 3

    class GatRenat extends Gat {
        GatRenat() {
            super();
        }
    }

D'aquesta manera, ``super()`` es tradueix pel constructor ``Gat()`` que
*no* està disponible!

Quan una classe no ofereix constructor per defecte, les seves subclasses
estan forçades a definir explícitament constructor.

Per exemple, una manera de resoldre-ho podria ser:

.. code-block:: java
    :linenos:

    class GatRenat extends Gat {
        public GatRenat(int vides) {
            super(vides);
        }
    }

O mantenint el constructor per defecte a ``GatRenat``:

.. code-block:: java
    :linenos:

    class GatRenat extends Gat {
        public GatRenat() {
            super(7);
        }
    }

