############################################################
|exerciseicon___| Exercici 35_13. Comparació de ``remove()``
############################################################

.. rubric:: Context

* Carpeta de lliurament: ``35_13_remove/``

* Continguts relacionats: :doc:`bib_lists`

* Com lliurar-lo: :ref:`instruccions <instruccions_git>`

.. rubric:: Enunciat

Quina de les dues implementacions de ``List`` que estem treballant
(``ArrayList``, ``LinkedList``) funcionarà més ràpida amb l'operació
``remove()``?

Comprovem-ho!

Desenvolupa un programa anomenat ``ComparaRemove`` que comprovi el temps que
costa eliminar els elements d'una llista, tot eliminant-los sempre per l'inici,
pel final o pel punt mig.

Completa la següent implementació parcial, tot revisant que no et deixes cap
punt marcat amb ``XXX``.

.. code-block:: java
    :linenos:

    /*
        Comparació de l'operació remove() en ArrayList i LinkedList
        eliminant per l'inici, pel final i pel mig.

        Els resultats obtinguts han estat:

        Primera execució:
        =================

    Comparant l'eficiència de les llistes
    
    Comparació quan eliminem sempre de l'inici
    test remove(0) LinkedList:     XXX
    test remove(0) ArrayList:      XXX
    
    Comparació quan eliminem sempre del final
    test remove(últim) LinkedList: XXX
    test remove(últim) ArrayList:  XXX
    
    Comparació quan eliminem sempre del mig
    test remove(mig) LinkedList:   XXX
    test remove(mig) ArrayList:    XXX
    
            Segona execució:
            ================
    
    Comparant l'eficiència de les llistes
    
    Comparació quan eliminem sempre de l'inici
    test remove(0) LinkedList:     XXX
    test remove(0) ArrayList:      XXX
    
    Comparació quan eliminem sempre del final
    test remove(últim) LinkedList: XXX
    test remove(últim) ArrayList:  XXX
    
    Comparació quan eliminem sempre del mig
    test remove(mig) LinkedList:   XXX
    test remove(mig) ArrayList:    XXX
    
            Tercera execució:
            =================
    
    Comparant l'eficiència de les llistes
    
    Comparació quan eliminem sempre de l'inici
    test remove(0) LinkedList:     XXX
    test remove(0) ArrayList:      XXX
    
    Comparació quan eliminem sempre del final
    test remove(últim) LinkedList: XXX
    test remove(últim) ArrayList:  XXX
    
    Comparació quan eliminem sempre del mig
    test remove(mig) LinkedList:   XXX
    test remove(mig) ArrayList:    XXX
    
            Resultats
            =========
    
    ========== ================== ================== ======================================================
    **prova**  **linkedList**      **ArrayList**      **resultat**
    ---------- ------------------ ------------------ ------------------------------------------------------
    inici       XXX                 XXX                XXX
    final       XXX                 XXX                XXX
    mig         XXX                 XXX                XXX
    ========== ================== ================== ======================================================
    
        Per calcular cada columna:
    
        * la cel·la (1, 1) correspon al temps mig de la implementació LinkedList eliminant des de l'inici
          Es calcula sumant els valors obtinguts a les tres execucions i dividint-los per 3
    
        * el resultat per la fila inici indica quantes vegades és més ràpid un que l'altre. Per fer-ho, dividim
          el valor més petit pel més gran i arrodonim a l'enter.
    
        Conclusions
        ===========
    
        En vistes als resultats, en cas que hagi de fer servir una List per eliminar molts valors, escolliré XXX
    
         */
    import java.util.List;
    import java.util.ArrayList;
    import java.util.LinkedList;
    public class ComparaRemove {
        private static final int LONGITUD = 100000;
        private static List<Integer> emplena(List<Integer> llista) {
            // XXX codi que emplena la llista amb enters del 0 a LONGITUD - 1
            return llista;
        }
        private static long testRemove0(List<Integer> llista) {
            long tempsInicial = System.nanoTime();
            // XXX codi que elimina un a un tots els elements de la llista per la posició 0
            return System.nanoTime() - tempsInicial;
        }
        private static long testRemove(List<Integer> llista) {
            long tempsInicial = System.nanoTime();
            // XXX codi que elimina un a un tots els elements de la llista per la darrera posició
            return System.nanoTime() - tempsInicial;
        }
        private static long testRemoveMig(List<Integer> llista) {
            long tempsInicial = System.nanoTime();
            // XXX codi que elimina un a un tots els elements de la llista per la posició mig
            return System.nanoTime() - tempsInicial;
        }
        public static void main(String[] args) {
            System.out.println("Comparant l'eficiència de les llistes");
            System.out.println();

            System.out.println("Comparació quan eliminem sempre de l'inici");
            System.out.printf("test remove(0) LinkedList:     %10d%n", testRemove0(emplena(new LinkedList<Integer>())));
            System.out.printf("test remove(0) ArrayList:      %10d%n", testRemove0(emplena(new ArrayList<Integer>())));
            System.out.println();

            System.out.println("Comparació quan eliminem sempre del final");
            System.out.printf("test remove(últim) LinkedList: %10d%n", testRemove(emplena(new LinkedList<Integer>())));
            System.out.printf("test remove(últim) ArrayList:  %10d%n", testRemove(emplena(new ArrayList<Integer>())));
            System.out.println();

            System.out.println("Comparació quan eliminem sempre del mig");
            System.out.printf("test remove(mig) LinkedList:   %10d%n", testRemoveMig(emplena(new LinkedList<Integer>())));
            System.out.printf("test remove(mig) ArrayList:    %10d%n", testRemoveMig(emplena(new ArrayList<Integer>())));
            System.out.println();
        }
    }



