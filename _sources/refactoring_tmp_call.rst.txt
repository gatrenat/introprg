####################
Temporals per crides
####################

En aquesta entrada coneixerem un nou pas de refacció conegut com a
*reemplaçament de variable temporal per crida*.

Aquest pas de refacció cerca eliminar variables temporals que només són
assignades un cop i substituir-les pel valor assignat allà on calgui.

Per exemple, considera el següent fragment de codi:

.. code-block:: java

    int preuBase = this.quantitat + this.preuUnitari;
    if (preuBase > 1000 ) {
        return preuBase * 0.90;
    } else {
        return preuBase;
    }

Aquest pas el codificaria com:

.. code-block:: java

    if (preuBase() > 1000) {
        return preuBase() * 0.90;
    } else {
        return preuBase();
    }

Amb el nou mètode que encapsula l'expressió inicial:

.. code-block:: java

    double preuBase() {
        return this.quantitat + this.preuUnitari;
    }

La creació del nou mètode és un altre exemple de pas d'*extracció de mètode*
que hem vist abans.

Es pot argumentar que aquesta transformació resulta en un codi menys eficient
en execució. Podria ser! Él preu base passa a calcular-se múltiples cops en
comptes d'un. En aquest cas, el càlcul és molt lleuger i és possible, fins i
tot, que Java l'optimitzi. Ens podriem trobar, però, amb càlculs més costosos.
Per exemple, un recorregut d'una llista d'elements.

Quin benefici en treurem d'aquest canvi, aparentment a pitjor? Aquest canvi
elimina del codi dependències a variables temporals, amb el que ens facilita
realitzar extraccions de mètodes.

.. important:: Recordem que l'eficiència en la llegibilitat/modificabilitat del
   codi és normalment molt més desitjable que l'eficiència en l'execució de
   codi. Abans de decidir-nos per un codi menys llegible justificant-lo amb el
   rendiment em execució, és important tenir molt clar com afecta al rendiment
   de l'aplicació. Molts cops ens trobarem que el guany de rendiment és molt
   petit. D'altres cops veurem que el codi més clar permet optimitzacions a més
   alt nivell.

En el codi que estem treballant, al mètode ``Client.informe()`` hi trobem la
variable ``quantitat`` que actuaria com a variable temporal. 

.. code-block:: java
    :linenos:
    :emphasize-lines: 8, 24, 25

    public String informe() {
        double total = 0;
        int bonificacions = 0;
        String resultat = "Informe de lloguers del client " + 
            getNom() + 
            " (" + getNif() + ")\n";
        for (Lloguer lloguer: lloguers) {
            double quantitat = // XXX Part d'un exercici previ

            // afegeix lloguers freqüents
            bonificacions ++;

            // afegeix bonificació per dos dies de lloguer de Luxe
            if (lloguer.getVehicle().getCategoria() == Vehicle.LUXE &&
                    lloguer.getDies()>1 ) {
                bonificacions ++;
            }

            // composa els resultats d'aquest lloguer
            resultat += "\t" + 
                lloguer.getVehicle().getMarca() + 
                " " + 
                lloguer.getVehicle().getModel() + ": " +
                (quantitat * 30) + "€" + "\n";
            total += quantitat * 30;
        }

        // afegeix informació final
        resultat += "Import a pagar: " + total + "€\n" +
            "Punts guanyats: " + bonificacions + "\n";
        return resultat;
    }

|exerciseicon__T| :doc:`exercici_52_19_temporal`

