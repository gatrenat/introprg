############
Constructors
############

Coneixerem ara els *constructors*, un tipus especial de bloc de codi
(*mòdul*) que en programació orientada a objectes és cridat per realitzar
la creació d'una nova instància d'una classe, i que té la funció de
preparar la instància per a ser utilitzada.

Aquesta introducció comença amb una secció *teòrica* que descriu els
constructors (i destructors), per després continuar amb l'anàlisi
d'exercicis en Java.

Però si ja els coneixem!
========================

En realitat ja hem fet servir els constructors. En el tema
:doc:`poo_intro` hem vist codi que fa:

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        -vides
        +getVides(): int
     }
     @enduml

.. code-block:: java
    :linenos:
    :emphasize-lines: 6

    public class GatRenat {
        private int vides = 7;
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

A la línia 6 estem creant o *construint* una instància de ``GatRenat``. Un
cop executada, sabem que la referència ``renat`` queda inicialitzada a un
valor de tipus ``GatRenat``.

Veiem-ho pas a pas començant per la línia 5:

.. code-block:: java
    :linenos:
    :emphasize-lines: 5

    public class GatRenat {
        private int vides = 7;
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Podem representar la part que ens interessa de la memòria del programa de
la següent manera:


.. image:: _images/constructors_01.svg
   :align: center
   :width: 50%

``renat`` és una variable. El seu valor de moment és indeterminat, ja que no ha
estat inicialitzada. Considerarem que el valor de la variable ``renat`` estarà
allotjat a la posició de memòria ``@100``.

De moment no tenim cap gat instanciat. Només un nom (``renat``) que en pot
fer referència. Passem a la següent línia:

.. code-block:: java
    :linenos:
    :emphasize-lines: 6

    public class GatRenat {
        private int vides = 7;
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

En primer lloc, l'expressió ``new GatRenat()`` ens reservarà un espai de
memòria, diguem a la posició ``@1000`` que contindrà el valor de la propietat
``vida`` i, potser, altres coses.

En inicialitzar ``renat`` amb aquesta posició, ja podem referir-nos a la
instància des de la novstra variable.

Ho podem representar de manera simplificada, de la següent manera:

.. image:: _images/constructors_02.svg
   :align: center
   :width: 75%

Passem a la següent línia:

.. code-block:: java
    :linenos:
    :emphasize-lines: 7

    public class GatRenat {
        private int vides = 7;
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

En aquesta ocasió, fem una crida al mètode ``getVides()`` que retornarà el
valor de la propietat de ``vides`` de la instància referida per la variable
``renat``. És a dir, la instància allotjada a la posició ``@1000``.

``renat.getVides()`` vindria a ser equivalent a ``renat.vides`` i, per tant,
aquesta instrucció resultarà en assignar ``7`` a ``vides``:

.. image:: _images/constructors_03.svg
   :align: center
   :width: 75%

En fer ``renat.getVides()`` la funció ``getVides()`` *sap* d'alguna manera que
el valor de ``renat`` és (o fa referència a) la posició ``@1000`` i per tant,
és capaç de localitzar el seu camp ``vides``, i retornar el seu valor: ``7``.


Un lleuger canvi
================

Considera ara aquesta nova versió de ``GatRenat`` que té exactament el mateix
resultat que l'anterior:

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        -vides
        +GatRenat()
        +getVides(): int
     }
     @enduml


.. code-block:: java
    :linenos:
    :emphasize-lines: 2-6

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Aquesta nova versió no inicialitza la propietat ``vides`` en la declaració. En
canvi, declara una mena de *mòdul* anomenat igual que la classe, que sí sembla
inicialitzar aquest camp!

Tornem a veure-ho pas a pas començant per la línia 9:

.. code-block:: java
    :linenos:
    :emphasize-lines: 9

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Representem la memòria inicial d'aquesta execució de la mateixa manera que
amb la versió anterior:

.. image:: _images/constructors_01.svg
   :align: center
   :width: 50%

En la següent línia ve quelcom interessant a l'hora de cridar ``new GatRenat()``.

.. code-block:: java
    :linenos:
    :emphasize-lines: 10

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Centrem-nos en el que passa un cop hem arribat a la línia 4 on només tenim
aquest misteriós comentari.

.. code-block:: java
    :linenos:
    :emphasize-lines: 4

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Les instruccions que no ens mostra el codi han *designat* un espai de
memòria suficient per emmagatzemar totes les propietats d'una instància de
la classe ``GatRenat`` i les ha inicialitzades al seu valor base. En ser
``vides`` un enter, aquest valor és ``0``.

.. image:: _images/constructors_04.svg
   :align: center
   :width: 75%

La posició d'aquest espai és referenciada per una variable temporal, que
al diagrama hem anomenat ``this``. Li podiem haver dit ``tmp`` però
el nom ``this`` és més significatiu.

Passem a la següent línia d'aquest mòdul tan especial:

.. code-block:: java
    :linenos:
    :emphasize-lines: 5

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

A la línia 5, el codi demana assignar ``7`` a la variable ``vides``.
Aquesta variable no està definida dins del mòdul i, per tant, podria
semblar que hauria de donar error. Però no ho fa.

No ho fa perquè Java, si no troba ``vides`` en aquest context, intentarà
trobar *una altra* ``vides`` tot afegint-li context. En concret,
reemplaçarà aquesta línia 5 per ``this.vides = 7``.

.. code-block:: java
    :linenos:
    :emphasize-lines: 5

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            this.vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Aquesta nova variable **sí** que existeix! Fa referència a la posició
``@1000.vides``. Així, en executar-la, ens trobem el següent canvi:

.. image:: _images/constructors_05.svg
   :align: center
   :width: 75%

És a dir, el valor corresponent a ``vides`` de l'espai de memòria que ha
estat assignat a la instància, ha passat a tenir el valor ``7``.

Un cop finalitzada l'execució de la línia 5, el mòdul ``GatRenat()`` també
finalitza l'execució. L'operador ``new`` de la línia 10 farà que el
resultat de l'expressió ``new GatRenat()`` sigui el valor de la variable
temporal que hem anomenat ``this``. És a dir ``1000``. Així, en acabar
d'executar la línia 10 tindrem:

.. image:: _images/constructors_02.svg
   :align: center
   :width: 75%

Tot plegat, estem en la mateixa situació que amb la versió del programa en
que la inicialització de ``vides`` es feia en la mateixa declaració.

Passem ara a la següent línia:

.. code-block:: java
    :linenos:
    :emphasize-lines: 11

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

En comptes de saltar-nos l'execució de ``getVides()`` ara *entrarem a
dins*.

Per poder entendre bé com es produeix aquesta crida, ens caldrà fer un
petit canvi *sintàctic*. ``renat.getVides()`` és una crida a una funció,
com sabem. Però no deixa de resultar estrany que ``renat``, una
referència a una instància de tipus ``GatRenat``, estigui abans de
``getVides()`` com si aquesta fos una de les propietats de ``GatRenat``
però sent codi. Estrany, oi?

Intentem-ho veure amb aquesta permutació:

    ``renat.getVides()`` → ``GatRenat.getVides(renat)``

**Atenció**: ``GatRenat.getVides(renat)`` no és vàlid en Java tal i com
està definit ``getVides()``. Per que la transformació funcionés, ens
caldria declarar ``getVides()`` de la següent manera:

.. code-block:: java
    :linenos:
    :emphasize-lines: 4-6, 10

    public class GatRenat {
        private int vides;
        public GatRenat() { vides = 7; }
        public static int getVides(GatRenat aquest) {
            return aquest.vides;
        }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = GatRenat.getVides(renat);
            System.out.printf("Vides: %d%n", vides);
        }
    }

**Nota**: he hagut d'anomenar el paràmetre com ``aquest`` en comptes de
``this`` perquè Java té reservat aquest nom i em donaria error.

Ara, en entrar a ``getVides()`` ens trobaríem la següent situació:

.. image:: _images/constructors_06.svg
   :align: center
   :width: 75%

Així, per executar ``return aquest.vides``, només hem d'accedir al
``vides`` de la posició ``@1000``, obtenir el valor ``7`` i retornar-lo.

En tornar al ``main()`` a la *seva* variable ``vides`` li quedarà assignat
el valor ``7`` retornat per ``getVides()``, el que ens deixarà novament:

.. image:: _images/constructors_03.svg
   :align: center
   :width: 75%


En resum: podem inicialitzar els valors dels camps de les instàncies de
``GatRenat`` tant directament a la línia de la declaració, com dins d'aquesta
mena de *mòdul* que es diu ``GatRenat()``.

Els constructors en Java
========================

Ja va sent hora de que el deixem d'anomenar *mena de mòdul* i li posem el nom
que li correspon: *constructor*.

Els *constructors* en Java tenen la forma d'un *mòdul* amb les següents
particularitats:

* el seu nom coincideix amb el de la classe

* no té valor de retorn, ni tant sols ``void``.

Potser t'estaràs preguntant: com és possible que fins ara hagi estat
instanciant gats Renats sense definir constructor? La resposta és: si no
explicitem un constructor, Java ens n'afegeix un automàticament. És a dir,
les següents dues definicions són equivalents:

.. code-block:: java

    public class GatRenat {
        // no cal indicar el constructor si no ha de fer res especial
    }

.. code-block:: java

    public class GatRenat {
        public GatRenat() {
            // no cal posar res aquí si no ha de fer res especial
        }
    }

|exerciseicon__T| :doc:`exercici_34_21_constructor`


Els constructors poden tenir paràmetres
=======================================

Una nova versió del codi anterior:

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        -vides
        +GatRenat(int)
        +getVides(): int
     }
     @enduml


.. code-block:: java
    :linenos:
    :emphasize-lines: 3, 9

    public class GatRenat {
        private int vides;
        public GatRenat(int novesVides) {
            vides = novesVides;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat(7);
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Aquesta nova versió presenta una novetat respecte l'anterior: El constructor
*rep* el valor amb el que ha d'inicialitzar les vides.

Fins ara, el constructor del nostre Renat no tenia cap paràmetre, però no
hi ha cap raó per que no els pugui tenir.

Que aquest nou constructor tingui un paràmetre té una implicació
important: podem decidir el nombre de vides inicial en el moment de la
creació!

Una altra implicació és que ara, per crear una instància de ``GatRenat`` ens
veiem en l'obligació d'indicar el valor inicial.

|exerciseicon__T| :doc:`exercici_34_22_constructor_parametritzat`

Tipus de constructors
=====================

El constructor sense paràmetres se'l coneix com a *constructor per
defecte* mentre que el paràmetritzat se'l coneix com a *constructor
específic*.

Java només ens afegirà automàticament el constructor per defecte i ho farà
només en el cas que no li indiquem nosaltres un altre constructor, sigui
per defecte o sigui específic.

És a dir, si no indiquem cap constructor, en tindrem un per defecte:

.. code-block:: java
   :emphasize-lines: 4

    public class GatRenat {
        private int vides;

        // no indiquem constructor: Java ja ens crearà un!

        public static void main(String[] args) {
            GatRenat renat = new GatRenat(); // puc construir
        }
    }

Però si indiquem un d'específic, Java no ens crearà el de per defecte
automàticament. El següent codi no compila:

.. code-block:: java
   :emphasize-lines: 7

    public class GatRenat {
        private int vides;

        public GatRenat(int novesVides) { vides = novesVides; }

        public static void main(String[] args) {
            GatRenat renat = new GatRenat(); // ERROR! ja no hi ha constructor per defecte!
                                             // Cal passar-li un argument
        }
    }


Vides desprotegides en néixer!
==============================

El constructor específic que hem creat a la versió anterior obre la porta
a errors: ara podem fer que ``vides`` tingui un valor inadequat des del
principi!

Per aquesta raó, ens caldrà protegir-la. Per exemple:

.. code-block:: java
    :linenos:
    :emphasize-lines: 4

    public class GatRenat {
        private int vides = 7;
        public GatRenat(int novesVides) {
            if (novesVides >= 0)  {
                vides = novesVides;
            }
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat(7);
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Fixa't que ara tornem a inicialitzar ``vides`` al valor per defecte ``7`` en
comptes del base ``0``. El constructor únicament posarà un valor diferent de
``vides`` en el cas que el que se li demani sigui considerat vàlid.

Encara millor, si volem que es pugui modificar ``vides`` després de la
inicialització, podem afegir el *setter* corresponent i aprofitar-ho des del
constructor!

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        -vides
        +GatRenat(int)
        +getVides(): int
        +setVides(int)
     }
     @enduml


.. code-block:: java
    :linenos:
    :emphasize-lines: 4, 7-11

    public class GatRenat {
        private int vides = 7;
        public GatRenat(int vides) {
            setVides(vides);
        }
        public int getVides() { return vides; }
        public void setVides(int novesVides) {
            if (novesVides >= 0)  {
                vides = novesVides;
            }
        }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat(7);
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Nota: en afegir el *setter* hem perdut la propietat d'immutabilitat que
gaudíem. Si la volguéssim continuar tenint, podríem simplement declarar el
*setter* com a privat.

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        -setVides(int)
     }
     @enduml


.. code-block:: java

        private void setVides(int novesVides) {
            if (novesVides >= 0)  {
                vides = novesVides;
            }
        }

|exerciseicon__T| :doc:`exercici_34_23_constructor_posicio`

En resum: hem de vigilar cada cop que oferim una nova possibilitat de
donar valor a un camp, que no estiguem obrint una porta per què l'estat de
la instància pugui quedar inconsistent.


``this``: La referència *misteriosa*
====================================

Ja hem parlat (`Un lleuger canvi`_) del ``this``. Atenció a
aquesta nova definició de ``GatRenat``:

.. code-block:: java
    :linenos:
    :emphasize-lines: 9

    public class GatRenat {
        private int vides = 7;
        public GatRenat(int vides) {
            setVides(vides);
        }
        public int getVides() { return vides; }
        public void setVides(int vides) {
            if (vides >= 0)  {
                this.vides = vides;
            }
        }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat(7);
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

La nova versió incorpora ``this`` al *setter** per diferenciar el camp
``vides`` del paràmetre ``vides``.

És clar, si no li posem, estaríem parlant de la mateixa variable: el
paràmetre ``vides`` i no la propietat ``vides``!. És a dir, que estaríem
fent ``vides = vides;`` cosa poc productiva, no creus?

El codi també funcionaria de la següent manera:

.. code-block:: java
    :linenos:
    :emphasize-lines: 4, 7

    public class GatRenat {
        private int vides;
        public GatRenat(int vides) {
            this.setVides(vides);
        }
        public int getVides() {
            return this.vides;
        }
        public void setVides(int vides) {
            if (vides >= 0) {
                this.vides = vides;
            }
        }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat(7);
            renat.setVides(6);
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

La referència ``this`` ens ve de *regal* a tots els mòduls de la classe que no
estiguin marcats amb la paraula ``static``. És a dir, ``main()`` no pot fer
servir ``this``.

Així, ``this`` fa referència a la mateixa instància que la variable a
partir de la que fem la crida:

.. image:: _images/constructors_07.svg
   :align: center
   :width: 75%

En resum, podem entendre que ``this`` és una referència que *neix* al
constructor i que mètodes com els accessors, reben a partir la referència
amb la que son cridats.

.. image:: _images/constructors_08.svg
   :align: center
   :width: 75%

Al ``this`` se'l coneix com el *paràmetre implícit* ja que, el mètode el
rep sense declarar-lo a la llista de paràmetres.

|exerciseicon__T| :doc:`exercici_34_24_aquesta_posicio`

Més d'un constructor
====================

Ara que ja sabem que podem tenir un constructor per defecte però també un
d'específic, ens podem plantejar si seria possible disposar dels dos.
Per exemple, en el cas del Gat Renat, el més normal és que hagi de néixer
amb 7 vides. No deixa de ser incòmode haver d'indicar 7 cada cop que en
volem un!

Això amb Java és possible gràcies al que es coneix com a
*sobrecàrrega* que vam descobrir a :doc:`aquest exercici
<exercici_34_18_assessinable>` sinó :doc:`abans <exercici_32_27_es_enter>`.

Considera aquesta nova versió del nostre amic:

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        -vides
        +GatRenat()
        +GatRenat(int)
        +getVides(): int
        +setVides(int)
     }
     @enduml

.. code-block:: java
    :linenos:
    :emphasize-lines: 3, 6, 16, 17

    public class GatRenat {
        private int vides = 7;
        public GatRenat() {
            setVides(7);
        }
        public GatRenat(int vides) {
            setVides(vides);
        }
        public int getVides() { return vides; }
        public void setVides(int novesVides) {
            if (novesVides >= 0)  {
                vides = novesVides;
            }
        }
        public static void main(String[] args) {
            GatRenat renatI = new GatRenat();
            GatRenat renatII = new GatRenat(8);
            System.out.printf("Renat I té %d vides%n", renatI.vides);
            System.out.printf("Renat II té %d vides%n", renatII.vides);
        }
    }

Fixa't que els dos constructors fan servir el *setter*. Encara que sabem
que 7 és un valor vàlid per vides, és una bona pràctica fer-ho així, doncs
ens assegura que si mai ens calgués fer res especial amb el cas del 7,
només ho hauríem de fer en un punt (el *setter*)

Encara podem fer-ho més modular, fent servir la nostra misteriosa
referència ``this``. Aquest cop amb un format encara més inquietant: com a
*crida*!

.. code-block:: java
    :linenos:
    :emphasize-lines: 4

    public class GatRenat {
        private int vides = 7;
        public GatRenat() {
            this(7);
        }
        public GatRenat(int vides) {
            setVides(vides);
        }
        public int getVides() { return vides; }
        public void setVides(int novesVides) {
            if (novesVides >= 0)  {
                vides = novesVides;
            }
        }
    }

La crida de la línia 7 està fent referència al constructor específic.
Per poder fer servir ``this()`` cal tenir present que ha de ser la primera
línia del cos del constructor, altrament ``javac`` es queixarà.


|exerciseicon__T| :doc:`exercici_34_25_molts_constructors`

|exerciseicon_ST| :doc:`exercici_34_26_hora`

|exerciseicon___| :doc:`exercici_34_27_resum`
