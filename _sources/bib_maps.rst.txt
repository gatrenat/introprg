##########
Clau-Valor
##########


Amb ``List`` hem conegut una manera d'agrupar instàncies de manera
seqüencial. És una manera molt habitual però no és la única.

En aquesta secció descobrirem una altra manera d'agrupar dades molt
típica: les parelles *clau-valor*

Les llistes, com de fet els *arrays*, identifiquen cada element per la
seva posició dins la seqüència.

Per exemple, considera aquesta llista:

.. code-block:: java

    List<Gat> gats = new ArrayList<>();
    gats.add(new Gat("Renat"));
    gats.add(new Gat("Garfield"));
    gats.add(new Gat("Misifú"));

.. image:: _images/maps_gats_as_list.svg
   :align: center
   :width: 50%

El diagrama anterior et mostra com, per referir-nos a un dels gats, fem
servir la seva posició a la llista.

Trobem l'entrada corresponent a ``"Renat"`` a la posició ``0`` de la
llista:

.. code-block:: java

   Gat renat = gats.get(0);

Si ens passen una llista de gats i volem saber si hi és el nostre amic
Renat, farem una cerca:

.. code-block:: java

    boolean hiEsRenat(List<Gat> gats) {
        for (Gat gat: gats) {
            if ("Renat".equals(gat.getNom())) return true;
        }
        return false;
    }

O encara millor, imagina't que ens cal fer alguna cosa amb el Renat si el
trobem:

.. code-block:: java

    Gat getRenat(List<Gat> gats) {
        for (Gat gat: gats) {
            if ("Renat".equals(gat.getNom())) return gat;
        }
        return null;
    }

Ara, amb ``getRenat()`` podem fer el següent:

.. code-block:: java

   Gat renat = getRenat(gats);
   if (renat != null) {
      renat.miola();
   }

Aquesta solució està bé però és millorable. Imagina que poguessis fer
simplement ``gats.get("Renat")``. 

Arriba ``Map``
==============

Considera el següent codi:

.. code-block:: java

   Map<String, Gat> gats = new HashMap<>();
   gats.put("Renat", new Gat("Renat"));
   gats.put("Garfield", new Gat("Garfield"));
   gats.put("Misifú", new Gat("Misifú"));

.. image:: _images/maps_gats.svg
   :align: center
   :width: 50%

Ara, fixa't:

.. code-block:: java

   Gat renat = gats.get("Renat");
   if (renat != null) {
      renat.miola();
   }

És a dir, per *referir-nos* a un gat concret, fem servir el seu nom!

Parelles clau-valor
===================

``Map<K, V>`` defineix una coŀlecció de parelles de dades. És a dir, cada
entrada d'un *map* consta de dos valors: la clau (de tipus *K*) i el valor
pròpiament dit (de tipus *V*).

En el cas del nostre exemple, el tipus de la clau és String, i el del
valor ``Gat``.

.. code-block:: java

   Map<String, Gat> gats = new HashMap<>();


``Map`` és una *interface* que declara mètodes per gestionar aquests
parells clau-valor: afegir, treure, eliminar i consultar a partir de la
clau.

Una representació parcial de la seva família és:

.. uml::
    :align: center

    @startuml

    hide circle
    hide empty members

    skinparam class {
        BackgroundColor White
        BorderColor Black
        ArrowColor Black
    }


    interface Map {
        clear()
        containsKey(Object): boolean
        containsValue(Object): boolean
        getOrDefault(Object key, V default): V
        isEmpty(): boolean
        put(K key, V value): V
        remove(Object): V
        size(): int
    }

    class AbstractMap <<abstract>> implements Map
    class HashMap extends AbstractMap
    class TreeMap extends AbstractMap

    @enduml

La classe `HashMap
<https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/HashMap.html>`_
implementa la *interface* ``Map`` de manera que trobar el valor a partir
de la clau sigui molt ràpid. A canvi, els programes que el facin servir no
poden assumir cap ordre en les claus.

La classe `TreeMap
<https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/TreeMap.html>`_
també és un ``Map`` però sí que manté l'ordre d'entrada de les claus. Per
contra, no és tan ràpid com ``HashMap`` en la majoria dels mètodes bàsics.

L'elecció entre aquestes dues implementacions (i d'altres) no sempre és
trivial ja que depen molt d'un nombre significatiu de condicions d'ús, com
ara: si ens cal o no preservar l'ordre, quantes parelles hem d'afegir,
quantes parelles *sabem* que hem d'afegir inicialment, de
quina manera les consultarem, etc. Per les necessitats d'aquest curs,
ens resultarà indiferent quina escollim.

A l'igual que amb ``List``, tant la clau com el valor no poden ser de
tipus primitiu. En cas que ens calgui sempre podem fer servir la classe
*embolcall* (*wrapper*) corresponent. Recorda per exemple ``int`` →
``Integer``.

Veiem un exemple que fa servir un ``HashMap``:

.. code-block:: none
    :linenos:

    ~/$ jshell
    |  Welcome to JShell -- Version 11.0.14
    |  For an introduction type: /help intro

    jshell> Map<String, List<Integer>> notes = new HashMap<>()
    notes ==> {}

    jshell> notes.put("Eleftèria", new ArrayList<Integer>());
    $2 ==> null

    jshell> List<Integer> notesElefteria = notes.get("Eleftèria");
    notesElefteria ==> []

    jshell> notesElefteria.add(5);
    $4 ==> true

    jshell> notesElefteria.add(4);
    $5 ==> true

    jshell> notesElefteria.add(6);
    $6 ==> true

    jshell> notes.get("Eleftèria")
    $7 ==> [5, 4, 6]

    jshell> notes.put("Aina", new ArrayList<Integer>());
    $8 ==> null

    jshell> notes.get("Aina");
    $9 ==> []

    jshell> notes.get("Aina").add(8);
    $10 ==> true

    jshell> notes.get("Aina").add(9);
    $11 ==> true

    jshell> notes.get("Aina").add(7);
    $12 ==> true

    jshell> notes.get("Saul");
    $13 ==> null

    jshell> notes.getOrDefault("Saul", new ArrayList<Integer>());
    $14 ==> []

Fixa't que, en aquest cas, la clau ha estat el nom i el valor un
``List<Integer>``


Igualtat
========

Les classes que habitualment fem servir (ex. ``String``, ``Integer``)
estan ben definides per poder funcionar com a claus d'un ``Map``, però si
decidíssim tenir una clau d'una classe nostra (ex. ``Gat``) ens caldria
assegurar que ``Map`` pot saber si dos gats són el mateix gat.


Què vol dir que dos objectes siguin iguals?

Probablement, estarem d'acord amb que dos objectes són iguals si fan
referència a la mateixa instància, oi? És clar, és la identitat la que
està en joc!

És a dir:

.. code-block:: java

   Gat gat1 = new Gat("Renat");
   Gat gat2 = new Gat("Renat");
   Gat gat3 = gat1;

   System.out.println("gat1 == gat2 -> " + (gat1 == gat2)); // false
   System.out.println("gat1 == gat3 -> " + (gat1 == gat3)); // true

``gat1`` i ``gat2`` són diferents malgrat tenen el mateix nom ja que
corresponen a instàncies diferents. En canvi, ``gat1`` i ``gat3`` sí
resulten ``true`` en comparar-los per igualtat, ja que són la mateixa
instància.

Sovint, però, no és la identitat el que ens importa. Per exemple, encara
que dos Strings no siguin la mateixa instància, si contenen el mateix
valor, volem considerar-los iguals:

.. code-block:: java

   String nom1 = "Renat";
   String nom2 = Entrada.readLine();   // suposa que introduïm "Renat"
   System.out.println("nom1 == nom2 -> " + (nom1 == nom2)); // false
   System.out.println("nom1.equals(nom2) -> " + (nom1.equals(nom2))); // true

Ja sabem que ``nom1`` i ``nom2`` difícilment estaran guardats en la
mateixa posició de memòria, però en aquest exemple, el seu contingut és el
mateix i, per tant ``String.equals()`` els considera iguals.

Considera la classe ``EnvoltaString`` que no fa res més que *envoltar* un
String.

.. code-block:: java
    :linenos:

    public class EnvoltaString {
        private String valor;

        public EnvoltaString(String valor) { this.valor = valor; }

        public String toString() { return String.format("ENVOLTAT(\"%s\")", valor); }

        public static void main(String[] args) {
            String nom1 = "Renat";
            String nom2 = new String("Renat");
            System.out.printf("\"%s\" == \"%s\" -> %b%n", nom1, nom2, nom1 == nom2);
            System.out.printf("\"%s\".equals(\"%s\") -> %b%n", nom1, nom2, nom1.equals(nom2));

            EnvoltaString envoltaNom1 = new EnvoltaString(nom1);
            EnvoltaString envoltaNom2 = new EnvoltaString(nom2);
            System.out.printf("%s == %s -> %b%n", envoltaNom1, envoltaNom2, envoltaNom1 == envoltaNom2);
            System.out.printf("%s.equals(%s) -> %b%n", envoltaNom1, envoltaNom2, envoltaNom1.equals(envoltaNom2));
        }
    }

El codi anterior té com a sortida: 

.. code-block:: console
   :emphasize-lines: 2-

    $ java EnvoltaString
    "Renat" == "Renat" -> false
    "Renat".equals("Renat") -> true
    ENVOLTAT("Renat") == ENVOLTAT("Renat") -> false
    ENVOLTAT("Renat").equals(ENVOLTAT("Renat")) -> false

Com ja esperàvem, la comparació de Strings amb ``==`` ens havia de donar
``false`` ja que compara dues instàncies diferents. Per contra, el primer
``equals()`` ens generaria ``true``.

Perquè el primer ``equals()`` ens retorna ``true`` mentre que el segon ens
torna ``false`` malgrat tot el que contenen les instàncies són Strings amb
el mateix contingut?

Per donar resposta, ens cal entendre que els dos ``equals()`` no són el
mateix mètode. El primer pertany a la classe ``String`` i el segon a
``EnvoltaString``.

Però nosaltres no hem definit el mètode ``equals()`` a ``EnvoltaString``!
On està definit?

A ``Object`` és clar. ``EnvoltaString``, com qualsevol altra classe,
hereta d'``Object`` i ofereix directament els mètodes públics heretats
quan no els redefineix. Però lògicament a ``Object`` no li podem demanar
que sàpiga com comparar totes i cadascuna de les seves subclasses!

Imagina-t'ho només amb ``EnvoltaString``. Quan hauria de considerar que
dos ``EnvoltaString`` són iguals? Quan els seus valors són iguals (segons
``String.equals()``)? Quan siguin iguals independents de majúscules i
minúscules?

Nosaltres decidim què fa iguals a dues instàncies de ``EnvoltaString``
i, per tant, nosaltres haurem de desenvolupar el codi per
comparar-les. 

.. code-block:: java
    :linenos:
    :emphasize-lines: 8-10

    public class EnvoltaString {
        private String valor;

        public EnvoltaString(String valor) { this.valor = valor; }

        public String toString() { return String.format("ENVOLTAT(\"%s\")", valor); }

        public boolean equals(EnvoltaString altre) {
            return valor.equals(altre.valor);
        }

        public static void main(String[] args) {
            String nom1 = "Renat";
            String nom2 = new String("Renat");
            System.out.printf("\"%s\" == \"%s\" -> %b%n", nom1, nom2, nom1 == nom2);
            System.out.printf("\"%s\".equals(\"%s\") -> %b%n", nom1, nom2, nom1.equals(nom2));

            EnvoltaString envoltaNom1 = new EnvoltaString(nom1);
            EnvoltaString envoltaNom2 = new EnvoltaString(nom2);
            System.out.printf("%s == %s -> %b%n", envoltaNom1, envoltaNom2, envoltaNom1 == envoltaNom2);
            System.out.printf("%s.equals(%s) -> %b%n", envoltaNom1, envoltaNom2, envoltaNom1.equals(envoltaNom2));
        }
    }

Fixa't que sobreescrivim ``equals()`` de manera que, en rebre un altre
``EnvoltaString``, indiqui cert si els valors són iguals segons
``String.equals()``.

La sortida d'aquest programa, com era d'esperar, serà: 

.. code-block:: console
   :emphasize-lines: 2-

    $ java EnvoltaString 
    "Renat" == "Renat" -> false
    "Renat".equals("Renat") -> true
    ENVOLTAT("Renat") == ENVOLTAT("Renat") -> false
    ENVOLTAT("Renat").equals(ENVOLTAT("Renat")) -> true

|exerciseicon__T| :doc:`exercici_35_17_envoltastring_case`


Què passaria si provéssim el següent codi? 

.. code-block:: java

    EnvoltaString envoltat = new EnvoltaString("Renat");
    System.out.println(envoltat.equals(new java.util.ArrayList<GatRenat>()));

Fixa't que estem comparant un ``EnvoltaString`` amb un ``ArrayList`` de gats Renat!
Com seria d'esperar, el resultat que es mostra per pantalla és ``false`` però,
com és possible?
Perquè no resulta en un error? Perquè Java no es queixa quan intentem
accedir a ``altre.nom``?

La resposta és, perquè no s'està executant el ``EnvoltaString.equals()``
sinó ``Object.equals()``. Perquè?

Trobem una bona pista si afegim l'anotació ``@Override``:

.. code-block:: java
   :linenos:
   :emphasize-lines: 6, 9

    public class EnvoltaString {
        private String valor;

        public EnvoltaString(String valor) { this.valor = valor; }

        @Override
        public String toString() { return String.format("ENVOLTAT(\"%s\")", valor); }

        @Override
        public boolean equals(EnvoltaString altre) {
            return valor.equals(altre.valor);
        }
    }

En intentar compilar el codi anterior, rebem el següent:

.. code-block:: console
   :emphasize-lines: 2-

    $ javac EnvoltaString.java 
    EnvoltaString.java:9: error: method does not override or implement a method from a supertype
        @Override
        ^
    1 error

El que ens està dient és que **no** hem redefinit el mètode ``equals()``
de ``Object`` ja que la seva signatura és ``equals(Object)`` i no
``equals(EnvoltaString)``. El que hem fet és *sobrecarregar* el nom
``equals()``.

Per poder redefinir ``equals()`` ens caldrà fer el següent: 

.. code-block:: java
    :linenos:

    @Override
    public boolean equals(Object obj) {
        if (obj instanceof EnvoltaString) {  // si ja ni tant sols és ni un EnvoltaString malament
            EnvoltaString altre = (EnvoltaString) obj;
            return valor.equals(altre.valor);
        }
        return false;
    }

|exerciseicon__T| :doc:`exercici_35_18_envoltastring_str`

No hi ha prou amb ser iguals
============================

Si les coses fossin tan fàcils com redefinir el mètode ``equals()``,
Java seria massa avorrit.

Considera el següent codi:

.. code-block:: java
   :linenos:
   :emphasize-lines: 9

    import java.util.Map;
    import java.util.HashMap;
    public class EnvoltaMap {
        public static void main(String[] args){
            Map<String, EnvoltaString> map = new HashMap<>();
            map.put(new String("Renat"), new EnvoltaString("Renat"));
            map.put(new String("Garfield"), new EnvoltaString("Garfield"));
            map.put(new String("Misifú"), new EnvoltaString("Misifú"));
            map.put(new String("Renat"), new EnvoltaString("Renat II"));
            for (String clau: map.keySet()) {
                System.out.printf("\"%s\" -> %s%n", clau, map.get(clau));
            }
        }
    }

El codi anterior crea un ``HashMap<String, EnvoltaString>`` i hi introdueix quatre parelles
clau-valor' dues d'elles amb la mateixa clau.

La sortida resultant del programa és:

.. code-block:: console
   :emphasize-lines: 2-

    $ java EnvoltaMap 
    "Garfield" -> ENVOLTAT("Garfield")
    "Misifú" -> ENVOLTAT("Misifú")
    "Renat" -> ENVOLTAT("Renat II")

És possible que a tu t'apareguin en un altre ordre ja que estem fent
servir ``HashMap``. En tot cas, el valor corresponent a ``"Renat"`` ja no
serà ``"Renat"`` sinó ``"Renat II"``. Perquè? Perquè l'assignació de la
línia 9 fa canviar el valor associat a la clau ``"Renat"``. És el que
esperaríem, oi?

Fem-ho ara a l'inrevés. És a dir, fem que ara la clau sigui
``EnvoltaString`` en comptes de ``String``:

.. code-block:: java
   :linenos:
   :emphasize-lines: 9

    import java.util.Map;
    import java.util.HashMap;
    public class EnvoltaMap {
        public static void main(String[] args){
            Map<EnvoltaString, String> map = new HashMap<>();
            map.put(new EnvoltaString("Renat"), "Renat");
            map.put(new EnvoltaString("Garfield"), "Garfield");
            map.put(new EnvoltaString("Misifú"), "Misifú");
            map.put(new EnvoltaString("Renat"), "Renat II");
            for (EnvoltaString clau: map.keySet()) {
                System.out.printf("%s -> \"%s\"%n", clau, map.get(clau));
            }
        }
    }

El codi és força similar a l'anterior. A veure què fa la sortida:

.. code-block:: console
   :emphasize-lines: 2-

    $ java EnvoltaMap 
    ENVOLTAT("Renat") -> "Renat"
    ENVOLTAT("Renat") -> "Renat II"
    ENVOLTAT("Garfield") -> "Garfield"
    ENVOLTAT("Misifú") -> "Misifú"

En primer lloc veiem un canvi d'ordre. És clar, ``HashMap`` no ens
garanteix l'ordre i, per tant, podem esperar qualsevol.

El més intrigant és, però, que hi ha quatre entrades! Sembla que l'entrada
de Renat s'ha duplicat!

Què està passant? És que no està funcionant el mètode ``equals()`` de
``EnvoltaString``?

En situacions així, una cosa que podem fer és comprovar què s'està
executant. Una manera molt simple és fer servir un *xivato*. 

Afegim un xivato al codi ``equals()``:

.. code-block:: java
   :emphasize-lines: 3

    @Override
    public boolean equals(Object element) {
        System.out.printf("XXX Cridat %s.equals(%s)%n", this, element);
        if (! (element instanceof EnvoltaString)) return false;
        EnvoltaString altre = (EnvoltaString) element;
        return valor.equals(altre.valor);
    }

Un cop recompilat, si tornem a executar el ``EnvoltaMap`` ens trobem…
exàctament la mateixa sortida! Sembla que no s'està cridant ``equals()``
de ``EnvoltaString``.

Mirem què ens diu la documentació del mètode `Object.equals()
<https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)>`_:

Al final de la descripció tenim la pista en forma de nota:

    Noteu que generalment és necessari sobreescriure el mètode
    ``hashCode()`` quan aquest métode [``equals()``] és sobreescrit, de
    manera que se mantingui el contracte general del mètode ``hashCode()``
    que requereix que els objectes iguals han de tenir codis *hash*
    iguals.

El que ens està dient és que si sobreescrivim ``equals()`` generalment
haurem de sobreescriure un altre mètode anomenat ``hashCode()``. En
consultar la `seva documentació
<https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#hashCode()>`_
ens trobem que ``hashCode()`` requereix:

* sempre que el cridem sobre la mateixa instància, haurà de retornar el
  mateix valor.

* si ``equals()`` ens diu que dues instàncies són iguals, ``hashCode()`` ens
  ha de retornar el mateix valor per les dues instàncies.

* no és necessari que dos instàncies diferents resultin en valors
  diferents de ``hashCode()``. Amb tot, és recomanable per millorar el
  funcionament de les classes que fan servir taules de *hash* (recordes
  ``HashMap``?)

És a dir, que ens toca redefinir també el mètode ``hashCode()`` per
``EnvoltaString``

Per saber quin valor li fem tornar a ``hashCode()`` hauríem d'investigar
una mica quines són les bones pràctiques. Alguns IDE ens oferiran opcions per generar-ho per nosaltres!
En aquest cas concret, però, ho tenim força fàcil,
ja que podem simplement retornar el valor de *hash* del String envoltat:

.. code-block:: java
    :linenos:

    public class EnvoltaString {
        private String valor;

        public EnvoltaString(String valor) { this.valor = valor; }

        @Override
        public String toString() { return String.format("ENVOLTAT(\"%s\")", valor); }

        @Override
        public boolean equals(Object element) {
            System.out.printf("XXX Cridat %s.equals(%s)%n", this, element);
            if (! (element instanceof EnvoltaString)) return false;
            EnvoltaString altre = (EnvoltaString) element;
            return valor.equals(altre.valor);
        }

        @Override
        public int hashCode() {
            System.out.printf("XXX Cridat %s.hashCode()%n", this);
            return valor.hashCode();
        }
    }

Si executem ara ``EnvoltaMap`` ens trobem la següent sortida:

.. code-block:: console
   :emphasize-lines: 2-

    $ java EnvoltaMap
    ENVOLTAT("Garfield") -> "Garfield"
    ENVOLTAT("Misifú") -> "Misifú"
    ENVOLTAT("Renat") -> "Renat II"

Per fi tenim el que esperàvem! ``HashMap`` ha considerat que les dues
instàncies que corresponen a Renat són *iguals*.

Si tornem a posar els *xivatos* podrem veure què ha passat per dins:

.. code-block:: console
   :emphasize-lines: 2-

    $ java EnvoltaMap
    XXX Cridat ENVOLTAT("Renat").hashCode()
    XXX Cridat ENVOLTAT("Garfield").hashCode()
    XXX Cridat ENVOLTAT("Misifú").hashCode()
    XXX Cridat ENVOLTAT("Renat").hashCode()
    XXX Cridat ENVOLTAT("Renat").equals(ENVOLTAT("Renat"))
    XXX Cridat ENVOLTAT("Garfield").hashCode()
    ENVOLTAT("Garfield") -> "Garfield"
    XXX Cridat ENVOLTAT("Misifú").hashCode()
    ENVOLTAT("Misifú") -> "Misifú"
    XXX Cridat ENVOLTAT("Renat").hashCode()
    ENVOLTAT("Renat") -> "Renat II"

Fixa't que ``hashCode()`` és cridat en nombroses ocasions. fins i tot per
part de ``get()``! En canvi, ``equals()`` és executat un únic cop, i ho fa
per comparar la instància corresponent a Renat!.

Així, ``HashMap`` el que fa per localitzar una clau és:

1. obté el *hash* de la clau a localitzar fent servir ``hashCode()``

2. si hi ha una clau amb el mateix *hash*, crida ``equals()``

3. considerarà que la clau hi és quan troba una clau que tingui el mateix
   *hash* i ``equals()`` digui que és igual a la cercada.

|exerciseicon__T| :doc:`exercici_35_19_especmap`
